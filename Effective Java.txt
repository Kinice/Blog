【创建和销毁对象】
·考虑用静态工厂方法代替构造器
提供静态工厂方法而不是公有的构造器
静态工厂方法比构造器优势：有名称；不必每次调用创建新对象；返回任何子类型对象；创建参数化类型实例时，代码更简洁。
Map<String,List<String>> m = new HashMap<String,List<String>>();
类型推导type inference
public static <K,V> HashMap<K,V> newInstance{
	return new HashMap<K,V>();
}
Map<String,List<String>> m = HashMap.newInstance();
缺点：类如果不含公有的或者受保护的构造器，就不能被子类化；与其他的静态方法实际上没有任何区别。
·遇到多个构造器参数时要考虑用构建器
·用私有构造器或者枚举类型强化Singleton属性：
1.公有静态成员
public class Elvis{
	public static final Elvis INSTANCE = new Elvis();
	private Elvis(){...}
}
2.公有静态方法
public class Elvis{
	private static final Elvis INSTANCE = new Elvis();
	private Elvis(){...}
	public static Elvis getInstance(){return INSTANCE;}
}
3.枚举
public enum Elvis{
	INSTANCE;
}
这种方法在功能上与公有域方法相近，但是它更加简洁，无偿的提供了序列化机制，绝对防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。虽然这种方法还没有广泛采用，但是单元素的枚举类型已经成为实现singleton的最佳方法。

//TODO 深入了解一下enum


·通过私有构造器强化不可实例化的能力
public class Utility{
	private Utility(){
		throw new AssertionError();
	}
}

·避免创建不必要的对象
Map接口的keySet方法返回该Map对象的Set视图，其中包含该Map中所有的key。粗看起来，好像每次调用keySet都返回同样的Set实例,但是，对于一个给定的Map对象，实际上每次调用keySet都返回同样的Set实例。

·消除过期的对象引用
过期引用obsolete reference。这类问题的修复方法很简单：一旦对象引用已经过期，只需清空这些引用即可。比如Stack的pop方法
public Object pop(){
	Object result = elements[--size];
	elements[size] = null;
	return result;
}
·避免使用终结方法
如果子类实现者覆盖了超类的终结方法，但是忘了手工调用超类的终结方法(或者有意选择不调用超类的终结方法)，那么超类的终结方法将永远也不会被调用到。


【对于所有对象都通用的方法】
Object的所有非final方法(equals，hashCode，toString，clone，finalize)都有明确的通用约定general contract，因为它们被设计成是要被覆盖override的。

·equals
equals方法实现了等价关系equivalence relation：自反性reflexive，对称性symmetric，传递性transitive，一致性consistent，非空性Non-nullity。
面向对象语言中关于等价关系的一个基本问题：我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定。
里氏替换原则Liskov substitution principle认为，一个类型的任何重要属性也将适用于它的子类型，因此为该类型编写的任何方法，在它的子类型上也应该同样运行的很好。
虽然没有一种令人满意的办法可以既扩展不可实例化的类，又增加值组件，但还是有一种不错的权宜之计workaround：复合优先于继承。
Timestamp扩展了Date，并增加了nanos域。所以有一个免责声明，不要混合使用Date和Timestamp对象。
实现高质量equals方法的诀窍：使用==操作符检查"参数是否为这个对象的引用"；使用instanceof操作符检查"参数是否为正确的类型";把参数转换成正确的类型;对于该类中的每个"关键significant"域，检查参数中的域是否与该对象中对应的域相匹配；问三个问题：是否对称，传递，一致。

·覆盖equals时总要覆盖hashCode

·始终要覆盖toString

·谨慎地覆盖clone
Cloneable接口的目的是作为对象的一个mixin接口mixin interface。遗憾的是，它并没有成功地达到这个目的，主要缺陷在于缺少一个clone方法。
实际上，clone方法就是另一个构造器；你必须确保它不会伤害到原始的对象，并确保正确的创建被克隆对象的约束条件invariant

·考虑实现Comparable接口
compareTo方法并没有在Object中声明。它是Comparable接口中唯一的方法。
类实现了Comparable接口，就表明它的实例具有内在的排序关系natural ordering。为实现Comparable接口的对象数组进行排序就这么简单:Arrays.sort(a);
compareTo方法的通用约定与equals方法的相似：将这个对象与指定的对象进行比较。当该对象小于、等于或大于指定对象的时候，分别返回一个负整数、零或者正整数.如果由于指定对象的类型而无法与该对象进行比较，则抛出ClassCastException异常。

【类和接口】
·使类和成员的可访问性最小化
模块之间只通过它们的API进行通信，一个模块不需要知道其他模块的内部工作情况。这个概念被称为信息隐藏information hiding或封装encapsulation
对于顶层的(非嵌套的)类和接口，只有两种可能的访问级别:包级私有的(package-private)和公有的(public)
对于成员(域、方法、嵌套类和嵌套接口)有四种可能的访问级别:私有的(private)——只有在声明该成员的顶层类内部才可以访问这个成员;包级私有的(package-private)——声明该成员的包内部的任何类都可以访问这个成员。从技术上讲，它被称为"缺省(default)访问级别"，如果没有为成员指定访问修饰符，就采用这个访问级别;受保护的(protected)——声明该成员的类的子类可以访问这个成员,并且该成员的包内部任何类也可以访问这个成员;共有的(public)——在任何地方都可以访问该成员。

·在公有类中使用访问方法而非公有域
setter和getter方法

·使可变性最小化
不可变类只是其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期lifetime内固定不变。
为了使类不会被扩展，要遵循下面五条规则:不要提供任何会修改对象状态的方法;保证类不会被扩展;使所有的域都成为私有的;使所有的域都是final的;确保对于任何可变组件的互斥访问。

·复合优先于继承
简而言之，继承的功能非常强大，但是也存在诸多问题，因为它违背了封装原则。只有当子类和超类之间确实存在子类型关系时，使用继承才是恰当的。即便如此，如果子类和超类在不同的包中，并且超类并不是为了继承而设计的，那么继承将会导致脆弱性(fragility)。避免这种脆弱性，可以用复合和转发机制来代替继承，尤其是当存在适当的接口可以实现包装类的时候。包装类不仅比子类更加健壮，而且功能也更加强大。

·要么为了继承而设计，并提供文档说明，要么就禁止继承
构造器决不能调用可被覆盖的方法。超类的构造器在子类的构造器之前运行，所以，子类中覆盖版本的方法将会在子类的构造器运行之前就先被调用。

·接口优于抽象类
现有的类可以很容易被更新，以实现新的接口
接口是定义mixin(混合类型)的理想选择
接口允许我们构造非层次结构的类型框架
通过对你导出的每个重要的接口都提供一个抽象的骨架实现(skeletal implementation)类，把接口和抽象类的优点结合起来。接口的作用仍然是定义类型，但是骨架实现类接管了所有与接口实现相关的工作。
接口一旦被公开发行，并且已被广泛实现，再想改变这个接口几乎是不可能的。

·接口只用于定义类型
