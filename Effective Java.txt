【创建和销毁对象】
·考虑用静态工厂方法代替构造器
提供静态工厂方法而不是公有的构造器
静态工厂方法比构造器优势：有名称；不必每次调用创建新对象；返回任何子类型对象；创建参数化类型实例时，代码更简洁。
Map<String,List<String>> m = new HashMap<String,List<String>>();
类型推导type inference
public static <K,V> HashMap<K,V> newInstance{
	return new HashMap<K,V>();
}
Map<String,List<String>> m = HashMap.newInstance();
缺点：类如果不含公有的或者受保护的构造器，就不能被子类化；与其他的静态方法实际上没有任何区别。
·遇到多个构造器参数时要考虑用构建器
·用私有构造器或者枚举类型强化Singleton属性：
1.公有静态成员
public class Elvis{
	public static final Elvis INSTANCE = new Elvis();
	private Elvis(){...}
}
2.公有静态方法
public class Elvis{
	private static final Elvis INSTANCE = new Elvis();
	private Elvis(){...}
	public static Elvis getInstance(){return INSTANCE;}
}
3.枚举
public enum Elvis{
	INSTANCE;
}
这种方法在功能上与公有域方法相近，但是它更加简洁，无偿的提供了序列化机制，绝对防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。虽然这种方法还没有广泛采用，但是单元素的枚举类型已经成为实现singleton的最佳方法。

//TODO 深入了解一下enum


·通过私有构造器强化不可实例化的能力
public class Utility{
	private Utility(){
		throw new AssertionError();
	}
}

·避免创建不必要的对象
Map接口的keySet方法返回该Map对象的Set视图，其中包含该Map中所有的key。粗看起来，好像每次调用keySet都返回同样的Set实例,但是，对于一个给定的Map对象，实际上每次调用keySet都返回同样的Set实例。

·消除过期的对象引用
过期引用obsolete reference。这类问题的修复方法很简单：一旦对象引用已经过期，只需清空这些引用即可。比如Stack的pop方法
public Object pop(){
	Object result = elements[--size];
	elements[size] = null;
	return result;
}
·避免使用终结方法
如果子类实现者覆盖了超类的终结方法，但是忘了手工调用超类的终结方法(或者有意选择不调用超类的终结方法)，那么超类的终结方法将永远也不会被调用到。


【对于所有对象都通用的方法】
Object的所有非final方法(equals，hashCode，toString，clone，finalize)都有明确的通用约定general contract，因为它们被设计成是要被覆盖override的。

·equals
equals方法实现了等价关系equivalence relation：自反性reflexive，对称性symmetric，传递性transitive，一致性consistent，非空性Non-nullity。
面向对象语言中关于等价关系的一个基本问题：我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定。
里氏替换原则Liskov substitution principle认为，一个类型的任何重要属性也将适用于它的子类型，因此为该类型编写的任何方法，在它的子类型上也应该同样运行的很好。
虽然没有一种令人满意的办法可以既扩展不可实例化的类，又增加值组件，但还是有一种不错的权宜之计workaround：复合优先于继承。
Timestamp扩展了Date，并增加了nanos域。所以有一个免责声明，不要混合使用Date和Timestamp对象。
实现高质量equals方法的诀窍：使用==操作符检查"参数是否为这个对象的引用"；使用instanceof操作符检查"参数是否为正确的类型";把参数转换成正确的类型;对于该类中的每个"关键significant"域，检查参数中的域是否与该对象中对应的域相匹配；问三个问题：是否对称，传递，一致。

·覆盖equals时总要覆盖hashCode

·始终要覆盖toString

·谨慎地覆盖clone
Cloneable接口的目的是作为对象的一个mixin接口mixin interface。遗憾的是，它并没有成功地达到这个目的，主要缺陷在于缺少一个clone方法。
实际上，clone方法就是另一个构造器；你必须确保它不会伤害到原始的对象，并确保正确的创建被克隆对象的约束条件invariant

·考虑实现Comparable接口
compareTo方法并没有在Object中声明。它是Comparable接口中唯一的方法。
类实现了Comparable接口，就表明它的实例具有内在的排序关系natural ordering。为实现Comparable接口的对象数组进行排序就这么简单:Arrays.sort(a);
compareTo方法的通用约定与equals方法的相似：将这个对象与指定的对象进行比较。当该对象小于、等于或大于指定对象的时候，分别返回一个负整数、零或者正整数.如果由于指定对象的类型而无法与该对象进行比较，则抛出ClassCastException异常。

【类和接口】
·使类和成员的可访问性最小化
模块之间只通过它们的API进行通信，一个模块不需要知道其他模块的内部工作情况。这个概念被称为信息隐藏information hiding或封装encapsulation
对于顶层的(非嵌套的)类和接口，只有两种可能的访问级别:包级私有的(package-private)和公有的(public)
对于成员(域、方法、嵌套类和嵌套接口)有四种可能的访问级别:私有的(private)——只有在声明该成员的顶层类内部才可以访问这个成员;包级私有的(package-private)——声明该成员的包内部的任何类都可以访问这个成员。从技术上讲，它被称为"缺省(default)访问级别"，如果没有为成员指定访问修饰符，就采用这个访问级别;受保护的(protected)——声明该成员的类的子类可以访问这个成员,并且该成员的包内部任何类也可以访问这个成员;共有的(public)——在任何地方都可以访问该成员。

·在公有类中使用访问方法而非公有域
setter和getter方法

·使可变性最小化
不可变类只是其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期lifetime内固定不变。
为了使类不会被扩展，要遵循下面五条规则:不要提供任何会修改对象状态的方法;保证类不会被扩展;使所有的域都成为私有的;使所有的域都是final的;确保对于任何可变组件的互斥访问。

·复合优先于继承
简而言之，继承的功能非常强大，但是也存在诸多问题，因为它违背了封装原则。只有当子类和超类之间确实存在子类型关系时，使用继承才是恰当的。即便如此，如果子类和超类在不同的包中，并且超类并不是为了继承而设计的，那么继承将会导致脆弱性(fragility)。避免这种脆弱性，可以用复合和转发机制来代替继承，尤其是当存在适当的接口可以实现包装类的时候。包装类不仅比子类更加健壮，而且功能也更加强大。

·要么为了继承而设计，并提供文档说明，要么就禁止继承
构造器决不能调用可被覆盖的方法。超类的构造器在子类的构造器之前运行，所以，子类中覆盖版本的方法将会在子类的构造器运行之前就先被调用。

·接口优于抽象类
现有的类可以很容易被更新，以实现新的接口
接口是定义mixin(混合类型)的理想选择
接口允许我们构造非层次结构的类型框架
通过对你导出的每个重要的接口都提供一个抽象的骨架实现(skeletal implementation)类，把接口和抽象类的优点结合起来。接口的作用仍然是定义类型，但是骨架实现类接管了所有与接口实现相关的工作。
接口一旦被公开发行，并且已被广泛实现，再想改变这个接口几乎是不可能的。

·接口只用于定义类型
避免常量接口constant interface
简而言之，接口应该只被用来定义类型，它们不应该被用来导出常量

·类层次优于标签类
避免标签类tagged class

·用函数对象表示策略
简而言之，函数指针的主要用途就是实现策略(Strategy)模式。为了在Java中实现这种模式，要声明一个接口来表示该策略，并且为每个具体策略声明一个实现了该接口的类。当一个具体策略只被使用一次时，通常使用匿名类来声明和实例化这个具体策略类。当一个具体策略是设计用来重复使用的时候，它的类通常就要被实现为私有的静态成员，并通过共有的静态final域被导出，其类型为该策略接口。

·优先考虑静态成员类
嵌套类(nested class)是指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为它的外围类(enclosing class)提供服务。嵌套类有4种:静态成员类(static member class)、非静态成员类(nonstatic member class)、匿名类(anonymous class)和局部类(local class)

·请不要再新代码中使用原生态类型
Set<Object>是个参数化类型，表示可以包含任何对象类型的一个集合;Set<?>则是一个通配符类型，表示只能包含某种未知对象类型的一个集合;Set则是个原生态类型，它脱离了泛型系统。前两种是安全的，最后一种不安全。

·消除非受检警告
如果无法消除警告，同时可以证明引起警告的代码是类型安全的，(只有在这种情况下)才可以用一个@SuppressWarnings("unchecked")注解来禁止这条警告。

·列表优先于数组
数组是协变的(covariant)。Sub为Super的子类型，Sub[]就是Super[]的子类型。
泛型是不可变的(invariant)。List<Type1>和List<Type2>没什么关系。
总而言之，数组和泛型有着非常不同的类型规则。数组是协变且可以具体化的;泛型是不可变的且可以被擦除的。因此，数组提供了运行时的类型安全，但是没有编译时的类型安全。

·优先考虑泛型
总而言之，使用泛型比使用需要在客户端代码中进行转换的类型来的更加安全，也更加容易。在设计新类型的时候，要确保它们不需要这种转换就可以使用。

·优先考虑泛型方法
总而言之，泛型方法就像泛型一样，使用起来比要求客户端转换输入参数并返回值的方法来的更加安全，也更加容易。就像类型一样，你应该确保新方法可以不用转换就能使用，这通常意味着要将它们泛型化。

·利用有限制通配符来提升API的灵活性
PECS表示producer-extends,consumer-super。换句话说，如果参数化类型表示一个T生产者，就使用<? extends T>;如果它表示一个T消费者，就使用<? super T>。

·优先考虑类型安全的异构容器
总而言之，集合API说明了泛型的一般用法，限制你每个容器只能有固定数目的类型参数。你可以通过将类型参数放在键上而不是容器上来避开这一限制。对于这种类型安全的异构容器，可以用Class对象作为键。以这种方式使用的Class对象称作类型令牌。

·用enum代替int常量
 许多枚举都不需要显式的构造器或者成员，但许多其他枚举则受益于"每个常量与属性的关联"以及"提供行为受到这个属性影响的方法"。只有极少数的枚举受益于将多种行为与单个方法关联。在这种相对少见的情况下，特定于常量的方法要优先于启用自有值的枚举。如果多个枚举常量同事共享相同的行为，则考虑策略枚举。

 ·用实例域代替序数
 所有的枚举都有一个ordinal方法，它返回每个枚举常量在类型中的数字位置。永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中。

 ·用EnumSet代替位域
总而言之，正是因为枚举类型要用在集合(Set)中，所以没有理由用位域来表示它。

·用EnumMap代替序数索引
总而言之，最好不要用序数来索引数组，而要使用EnumMap。如果你所表示的这种关系是多维的，就使用EnumMap<...,EnumMap<...>>。应用程序的程序员在一般情况下都不适用Enum.ordinal，即使要用也很少，因此这是一种特殊情况。

·用接口模拟可伸缩的枚举
总而言之，虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟。

·注解优先于命名模式
除了"工具铁匠(toolsmiths——特定的程序员)"之外，大多数程序员都不必定义注解类型。但是所有的程序员都应该使用Java平台所提供的预定义的注解类型。还要考虑使用IDE或者静态分析工具所提供的任何注解。

·坚持使用Override注解
应该在你想要覆盖超类声明的每个方法生命中使用override注解


·用标记接口定义类型
标记接口(marker interface)是没有包含方法声明的接口，而只是指明一个类实现了具有某种属性的接口。
总而言之，标记接口和标记注解都各有用处。如果想要定义一个任何新方法都不会与之关联的类型，标记接口就是最好的选择。如果想要标记程序元素而非类和接口，考虑到未来可能要给标记添加更多的信息，或者标记要适合于已经广泛使用了注解类型的框架，那么标记注解就是正确的选择。


·检查参数的有效性
简而言之，每当编写方法或者构造器的时候，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法体的开头处，通过显式的检查来实施这些限制。

·必要时进行保护性拷贝

